# ClearPay Python Application Troubleshooting Guide

This document contains solutions for common Python issues in ClearPay platform.

## ConnectionRefusedError
**Problem:** Unable to establish connection to PostgreSQL database, connection actively refused
**Solution:** 
```python
import psycopg2
from psycopg2 import OperationalError
import time

def connect_with_retry(max_retries=5, delay=2):
    retries = 0
    while retries < max_retries:
        try:
            conn = psycopg2.connect(
                host="clearpay-db.internal",
                database="transactions",
                user="app_user",
                password="********",
                port="5432"
            )
            print("Connection established successfully")
            return conn
        except OperationalError as e:
            retries += 1
            print(f"Connection attempt {retries} failed: {e}")
            if retries < max_retries:
                time.sleep(delay)
    raise Exception("Failed to connect to database after multiple attempts")
```
**Module:** clearpay.db.connection

## TimeoutError
**Problem:** Database query execution timeout during peak transaction processing
**Solution:** 
```python
import psycopg2
from contextlib import contextmanager

@contextmanager
def transaction_timeout_handler(conn, timeout_seconds=30):
    try:
        # Set statement timeout
        with conn.cursor() as cur:
            cur.execute(f"SET statement_timeout = {timeout_seconds * 1000};")
        yield conn
    except psycopg2.errors.QueryCanceled:
        conn.rollback()
        raise TimeoutError("Query execution exceeded timeout limit during peak load")
    finally:
        # Reset timeout to default
        with conn.cursor() as cur:
            cur.execute("SET statement_timeout = 0;")
```
**Module:** clearpay.db.transaction

## ConnectionPoolExhaustedError
**Problem:** All connections in the database pool are in use, causing transaction failures
**Solution:** 
```python
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

# Configure engine with appropriate pool size and timeout
engine = create_engine(
    "postgresql+psycopg2://app_user:********@clearpay-db.internal:5432/transactions",
    poolclass=QueuePool,
    pool_size=20,
    max_overflow=10,
    pool_timeout=30,
    pool_recycle=1800
)

# Monitor pool statistics
def get_pool_status():
    return {
        "connections_in_use": engine.pool.checkedout(),
        "connections_available": engine.pool.size() - engine.pool.checkedout(),
        "total_connections": engine.pool.size(),
        "overflow": engine.pool.overflow()
    }
```
**Module:** clearpay.db.pool

## CredentialRotationError
**Problem:** Database authentication fails after automated credential rotation
**Solution:** 
```python
import os
import boto3
from botocore.exceptions import ClientError
import json
import psycopg2

def get_db_credentials():
    """Retrieve database credentials from AWS Secrets Manager"""
    secret_name = "clearpay/db/credentials"
    region_name = "us-east-1"
    
    session = boto3.session.Session()
    client = session.client(
        service_name='secretsmanager',
        region_name=region_name
    )
    
    try:
        get_secret_value_response = client.get_secret_value(
            SecretId=secret_name
        )
    except ClientError as e:
        raise e
    else:
        if 'SecretString' in get_secret_value_response:
            secret = get_secret_value_response['SecretString']
            return json.loads(secret)
        else:
            raise ValueError("Secret not found in expected format")

def create_connection():
    """Create database connection with credentials from Secrets Manager"""
    credentials = get_db_credentials()
    
    return psycopg2.connect(
        host=credentials['host'],
        database=credentials['dbname'],
        user=credentials['username'],
        password=credentials['password'],
        port=credentials['port']
    )
```
**Module:** clearpay.db.security

## DeadlockDetectedError
**Problem:** Transaction deadlock detected during concurrent payment processing
**Solution:** 
```python
import psycopg2
import random
import time
from functools import wraps

def with_deadlock_retry(max_retries=3, backoff_factor=0.5):
    """Decorator to retry transactions that encounter deadlocks"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            while retries <= max_retries:
                try:
                    return func(*args, **kwargs)
                except psycopg2.errors.DeadlockDetected:
                    retries += 1
                    if retries > max_retries:
                        raise
                    # Exponential backoff with jitter
                    sleep_time = backoff_factor * (2 ** retries) + random.uniform(0, 0.1)
                    time.sleep(sleep_time)
                    print(f"Deadlock detected, retrying operation (attempt {retries})")
        return wrapper
    return decorator

@with_deadlock_retry()
def process_payment(conn, payment_id, amount):
    with conn.cursor() as cur:
        # Use explicit transaction isolation level
        cur.execute("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE")
        
        # Update account balance
        cur.execute(
            "UPDATE accounts SET balance = balance - %s WHERE id = %s",
            (amount, payment_id)
        )
        
        # Create transaction record
        cur.execute(
            "INSERT INTO transactions (account_id, amount, type) VALUES (%s, %s, 'payment')",
            (payment_id, amount)
        )
        
        conn.commit()
```
**Module:** clearpay.payments.processor

## Error
**Problem:** Missing required API credentials in configuration file
**Solution:** 
```python
# config.py
CLEARPAY_CONFIG = {
    'api_key': 'cp_live_xxxxxxxxxxxxxxxxxxxxxxxx',
    'merchant_id': 'merchant_12345678',
    'secret_key': 'sk_live_xxxxxxxxxxxxxxxxxxxxxxxx',
    'environment': 'production',  # or 'sandbox' for testing
    'webhook_secret': 'whsec_xxxxxxxxxxxxxxxxxxxxxxxx'
}
```
**Module:** authentication

## Error
**Problem:** Incorrect timeout settings causing transaction failures
**Solution:** 
```python
# network_config.py
CLEARPAY_NETWORK_CONFIG = {
    'connection_timeout': 30,  # seconds
    'read_timeout': 120,  # seconds for long-running operations
    'max_retries': 3,
    'retry_delay': 2,  # seconds between retry attempts
    'backoff_factor': 1.5  # exponential backoff for retries
}
```
**Module:** networking

## Error
**Problem:** Invalid currency configuration causing payment rejections
**Solution:** 
```python
# payment_config.py
CLEARPAY_PAYMENT_CONFIG = {
    'supported_currencies': ['USD', 'AUD', 'GBP', 'CAD', 'NZD'],
    'default_currency': 'USD',
    'min_amount': {
        'USD': 1.00,
        'AUD': 1.00,
        'GBP': 1.00,
        'CAD': 1.00,
        'NZD': 1.00
    },
    'max_amount': {
        'USD': 2000.00,
        'AUD': 2000.00,
        'GBP': 1000.00,
        'CAD': 2000.00,
        'NZD': 2000.00
    }
}
```
**Module:** payment_processing

## Error
**Problem:** Webhook verification configuration missing required parameters
**Solution:** 
```python
# webhook_config.py
CLEARPAY_WEBHOOK_CONFIG = {
    'verify_signatures': True,
    'signature_header': 'clearpay-signature',
    'webhook_secret': 'whsec_xxxxxxxxxxxxxxxxxxxxxxxx',
    'tolerance_seconds': 300,  # Allow timestamps within 5 minutes
    'events_to_process': [
        'payment.approved',
        'payment.declined',
        'payment.voided',
        'refund.processed'
    ]
}
```
**Module:** webhooks

## Error
**Problem:** Logging configuration insufficient for debugging payment issues
**Solution:** 
```python
# logging_config.py
import logging

CLEARPAY_LOGGING_CONFIG = {
    'version': 1,
    'formatters': {
        'detailed': {
            'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        }
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'detailed'
        },
        'file': {
            'class': 'logging.handlers.RotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': '/var/log/clearpay/transactions.log',
            'maxBytes': 10485760,  # 10MB
            'backupCount': 10
        }
    },
    'loggers': {
        'clearpay': {
            'level': 'DEBUG',
            'handlers': ['console', 'file'],
            'propagate': False
        }
    }
}

logging.config.dictConfig(CLEARPAY_LOGGING_CONFIG)
```
**Module:** logging

## Memory Leak in Connection Pool

**Problem:** Connection objects aren't being properly closed after transactions, causing memory leaks and eventual resource exhaustion.

**Solution:**
```python
# Before: Connections not properly closed
def process_payment(payment_data):
    conn = connection_pool.get_connection()
    try:
        result = conn.execute_transaction(payment_data)
        return result
    except Exception as e:
        log_error(e)
        raise
    # Missing conn.close() or return to pool

# After: Using context manager to ensure connections are returned
def process_payment(payment_data):
    with connection_pool.get_connection() as conn:
        try:
            result = conn.execute_transaction(payment_data)
            return result
        except Exception as e:
            log_error(e)
            raise
```
**Module:** transaction_processor.py

## CPU-Bound Transaction Validation

**Problem:** Synchronous cryptographic validation of transactions is blocking the event loop, causing high latency during peak loads.

**Solution:**
```python
# Before: Blocking validation in main thread
def validate_transaction(tx_data):
    signature = tx_data.get('signature')
    payload = tx_data.get('payload')
    return crypto_engine.verify_signature(payload, signature)  # CPU-intensive

# After: Offloading to thread pool
from concurrent.futures import ThreadPoolExecutor

_executor = ThreadPoolExecutor(max_workers=8)

async def validate_transaction(tx_data):
    signature = tx_data.get('signature')
    payload = tx_data.get('payload')
    return await asyncio.get_event_loop().run_in_executor(
        _executor, crypto_engine.verify_signature, payload, signature
    )
```
**Module:** validation_service.py

## Inefficient Batch Processing

**Problem:** Processing transactions one at a time causes excessive database round trips and poor throughput during high volume periods.

**Solution:**
```python
# Before: Individual transaction processing
def process_transactions(transaction_list):
    results = []
    for transaction in transaction_list:
        result = db.execute_query("INSERT INTO transactions VALUES (%s, %s, %s)",
                                 (transaction.id, transaction.amount, transaction.status))
        results.append(result)
    return results

# After: Batch processing
def process_transactions(transaction_list):
    if not transaction_list:
        return []
        
    values = [(t.id, t.amount, t.status) for t in transaction_list]
    return db.execute_batch_query(
        "INSERT INTO transactions VALUES (%s, %s, %s)",
        values
    )
```
**Module:** batch_processor.py

## Memory Spike During Reporting

**Problem:** Monthly transaction reports load all transactions into memory at once, causing OOM errors with growing transaction volume.

**Solution:**
```python
# Before: Loading all transactions at once
def generate_monthly_report(month, year):
    transactions = db.query(f"SELECT * FROM transactions WHERE MONTH(created_at) = {month} AND YEAR(created_at) = {year}")
    report_data = process_all_transactions(transactions)  # Processes entire result set in memory
    return generate_report(report_data)

# After: Streaming with generators and chunked processing
def generate_monthly_report(month, year):
    report_data = {"total": 0, "categories": {}}
    
    # Process in chunks of 10000
    chunk_size = 10000
    offset = 0
    
    while True:
        transactions = db.query(
            f"SELECT * FROM transactions WHERE MONTH(created_at) = {month} AND YEAR(created_at) = {year} LIMIT {chunk_size} OFFSET {offset}"
        )
        
        if not transactions:
            break
            
        process_transaction_chunk(transactions, report_data)
        offset += chunk_size
        
    return generate_report(report_data)
```
**Module:** reporting_service.py

## InvalidTokenError
**Problem:** The authentication token provided is invalid or has expired.
**Solution:** 
```python
from clearpay import Client

# Refresh the token
client = Client(api_key="your_api_key", api_secret="your_api_secret")
new_token = client.auth.refresh_token()

# Use the new token for subsequent requests
response = client.payments.create(
    amount=1000,
    currency="USD",
    token=new_token
)
```
**Module:** clearpay.auth

## PermissionDeniedError
**Problem:** The API key has insufficient permissions to access the requested resource.
**Solution:** 
```python
from clearpay import Client

# Use a client with elevated permissions
client = Client(
    api_key="your_admin_api_key",
    api_secret="your_admin_api_secret",
    scopes=["payments:write", "refunds:write", "customers:read"]
)

# Verify permissions before making requests
if client.auth.has_permission("payments:write"):
    response = client.payments.create(amount=1000, currency="USD")
```
**Module:** clearpay.permissions

## CertificateVerificationError
**Problem:** SSL certificate verification failed when connecting to the ClearPay API.
**Solution:** 
```python
import ssl
from clearpay import Client, config

# Update CA certificates or configure the client properly
config.CA_BUNDLE_PATH = "/path/to/valid/cacerts.pem"

# Or if necessary in development only (not recommended for production)
client = Client(
    api_key="your_api_key",
    api_secret="your_api_secret",
    ssl_verify=False  # WARNING: Insecure, use only for debugging
)
```
**Module:** clearpay.network

## RateLimitExceededError
**Problem:** Authentication requests have exceeded the rate limit for token generation.
**Solution:** 
```python
from clearpay import Client
import time
from clearpay.exceptions import RateLimitExceededError

client = Client(api_key="your_api_key", api_secret="your_api_secret")

try:
    token = client.auth.generate_token()
except RateLimitExceededError as e:
    # Extract retry-after header value
    retry_seconds = e.retry_after
    print(f"Rate limited. Retrying in {retry_seconds} seconds")
    time.sleep(retry_seconds)
    token = client.auth.generate_token()
```
**Module:** clearpay.rate_limiter

## ApiKeyExpiredError
**Problem:** The API key used for authentication has expired and needs to be renewed.
**Solution:** 
```python
from clearpay import Client
from clearpay.exceptions import ApiKeyExpiredError

try:
    client = Client(api_key="your_expired_api_key", api_secret="your_api_secret")
    response = client.payments.list()
except ApiKeyExpiredError:
    # Generate a new API key from the ClearPay dashboard
    # Then use the new credentials
    client = Client(
        api_key="your_new_api_key",
        api_secret="your_new_api_secret"
    )
    response = client.payments.list()
```
**Module:** clearpay.auth